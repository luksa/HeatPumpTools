<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dependent Heating Curve Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        body { padding: 20px; }
        #chart { max-height: 600px; cursor: crosshair; }
        .header-container { position: relative; }
        .by-line {
            position: absolute;
            bottom: 0;
            right: 0;
            color: #6c757d;
        }
        @media (max-width: 576px) {
            .by-line { position: static; text-align: right; margin-top: 0.5rem; }
        }
        .narrow-input { max-width: 8ch; }
        .lwt-input-group { min-width: 320px; }
        #lwt-results p { margin-bottom: 0.5rem; font-weight: 500; }
        .lwt-row { align-items: flex-start; }
        .curve-title-wrapper { display: flex; align-items: center; gap: 6px; }
        .curve-title { cursor: pointer; min-width: 60px; }
        .edit-icon { cursor: pointer; font-size: 0.85em; opacity: 0.5; transition: opacity 0.2s; }
        .curve-title-wrapper:hover .edit-icon { opacity: 0.8; }
        .curve-title-input { display: inline-block; width: auto; min-width: 100px; }
        footer { margin-top: 4rem; text-align: center; color: #6c757d; font-size: 0.85rem; }
        .inputs-column { max-width: 400px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container mb-4">
            <h1 class="d-inline-block">Weather Dependent Heating Curve Visualizer</h1>
            <div class="by-line">
                By <a href="https://github.com/luksa" target="_blank">Marko Lukša</a>
            </div>
        </div>
        <p class="mb-4">
            This tool helps you visualize and fine-tune weather-dependent heating curves for heat pumps.
            Define each curve by two points, add multiple curves for easy comparison, and instantly see the leaving water temperature (LWT)
            for all curves at any chosen outdoor temperature.
        </p>
      
        <div class="row">
            <div class="col-md-4 order-md-1 mb-4 mb-md-0 inputs-column">
                <div id="curves-container" class="mb-4"></div>
                <button id="add-curve" class="btn btn-primary">Add Another Curve</button>
            </div>
          
            <div class="col-md-8 order-md-2">
                <canvas id="chart" class="mb-4"></canvas>
              
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3">What's my LWT at a given outdoor temperature?</h5>
                        <div class="row lwt-row">
                            <div class="col">
                                <div class="input-group lwt-input-group">
                                    <span class="input-group-text">Outdoor Temp</span>
                                    <input id="oat-input" type="number" step="1" class="form-control narrow-input">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                            <div class="col" id="lwt-results"></div>
                        </div>
                    </div>
                </div>
              
                <div class="card">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                            <h5 class="card-title mb-0">Share this curve</h5>
                            <button id="copy-clipboard" class="btn btn-secondary">
                                <i class="fas fa-copy"></i> Copy Link
                            </button>
                        </div>
                        <small id="copy-feedback" class="text-success d-none mt-3 d-block">Link copied to clipboard!</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
        Vibe-coded by <a href="https://github.com/luksa" target="_blank">Marko Lukša</a> with
        <a href="https://grok.com" target="_blank">Grok</a>.
        Inspired by <a href="https://vscope.at/heizkurve" target="_blank">vscope.at/heizkurve</a>.
    </footer>
  
    <script>
        let curves = [];
        let chart;
        const DEFAULT_MIN_X = -10;
        const DEFAULT_MAX_X = 25;
        const DEFAULT_MIN_Y = 20;
        const DEFAULT_MAX_Y = 40;
        const EXTEND_PADDING_X = 5;
        const EXTEND_PADDING_Y = 5;
        const SEPARATOR = ',';

        function makeTitleEditable(wrapper, titleSpan, index) {
            wrapper.addEventListener('click', () => {
                const currentText = titleSpan.textContent.trim();
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentText;
                input.className = 'form-control curve-title-input d-inline-block';
                titleSpan.style.display = 'none';
                wrapper.insertBefore(input, titleSpan.nextSibling);
                input.focus();
                input.select();
                const finishEditing = () => {
                    const newName = input.value.trim() || `Curve ${index + 1}`;
                    curves[index].name = newName;
                    titleSpan.textContent = newName;
                    input.remove();
                    titleSpan.style.display = 'inline';
                    updateChart();
                    updateURL();
                    calculateLWT(parseFloat(document.getElementById('oat-input').value) || NaN);
                };
                input.addEventListener('blur', finishEditing);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') finishEditing();
                    else if (e.key === 'Escape') {
                        input.remove();
                        titleSpan.style.display = 'inline';
                    }
                });
            });
        }

        function updateRemoveButtons() {
            const cards = document.querySelectorAll('#curves-container > .card');
            cards.forEach(card => {
                const removeBtn = card.querySelector('.remove');
                if (cards.length === 1) {
                    if (removeBtn) removeBtn.style.display = 'none';
                } else {
                    if (removeBtn) removeBtn.style.display = 'block';
                }
            });
        }

        function addCurve(data = {x1: -5, y1: 45, x2: 20, y2: 25, name: null}) {
            const container = document.getElementById('curves-container');
            const div = document.createElement('div');
            div.className = 'card mb-3';
            const index = container.children.length;
            const defaultName = `Curve ${index + 1}`;
            const name = data.name || defaultName;
            div.innerHTML = `
                <div class="card-body">
                    <h5 class="card-title">
                        <div class="curve-title-wrapper">
                            <span class="curve-title">${name}</span>
                            <i class="bi bi-pencil edit-icon"></i>
                        </div>
                    </h5>
                    <div class="mb-4">
                        <h6 class="fw-bold">Low Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-6 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-6">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x1" value="${data.x1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-6 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-6">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input y1" value="${data.y1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <h6 class="fw-bold">High Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-6 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-6">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x2" value="${data.x2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-6 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-6">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input y2" value="${data.y2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-danger remove">Remove Curve</button>
                </div>
            `;
            container.appendChild(div);
            const wrapper = div.querySelector('.curve-title-wrapper');
            const titleSpan = div.querySelector('.curve-title');
            makeTitleEditable(wrapper, titleSpan, index);
            div.querySelectorAll('input[type="number"]').forEach(input => input.addEventListener('change', updateAll));
            const removeBtn = div.querySelector('.remove');
            if (removeBtn) removeBtn.addEventListener('click', () => { div.remove(); updateAll(); });
            curves.push({ x1: data.x1, y1: data.y1, x2: data.x2, y2: data.y2, name });
            updateAll();
        }

        function updateAll() {
            const divs = document.querySelectorAll('#curves-container > .card');
            curves = [];
            divs.forEach((div, i) => {
                const x1 = parseFloat(div.querySelector('.x1').value);
                const y1 = parseFloat(div.querySelector('.y1').value);
                const x2 = parseFloat(div.querySelector('.x2').value);
                const y2 = parseFloat(div.querySelector('.y2').value);
                let name = div.querySelector('.curve-title').textContent.trim() || `Curve ${i + 1}`;
                if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
                    curves.push({x1, y1, x2, y2, name});
                }
            });
            updateRemoveButtons();
            updateChart();
            updateURL();
            calculateLWT(parseFloat(document.getElementById('oat-input').value) || NaN);
        }

        function getLWTForCurve(curve, oat) {
            let points = [{x: curve.x1, y: curve.y1}, {x: curve.x2, y: curve.y2}].sort((a, b) => a.x - b.x);
            const left = points[0];
            const right = points[1];
            if (oat <= left.x) return left.y;
            if (oat >= right.x) return right.y;
            const slope = (right.y - left.y) / (right.x - left.x);
            return left.y + slope * (oat - left.x);
        }

        function updateChart() {
            if (chart) chart.destroy();
            const ctx = document.getElementById('chart').getContext('2d');

            let allX = [], allY = [];
            curves.forEach(c => { allX.push(c.x1, c.x2); allY.push(c.y1, c.y2); });

            let minX = DEFAULT_MIN_X, maxX = DEFAULT_MAX_X;
            if (allX.length > 0) {
                minX = Math.min(minX, Math.min(...allX) - EXTEND_PADDING_X);
                maxX = Math.max(maxX, Math.max(...allX) + EXTEND_PADDING_X);
            }
            const displayMinX = Math.floor(minX);
            const displayMaxX = Math.ceil(maxX);

            let minY = DEFAULT_MIN_Y, maxY = DEFAULT_MAX_Y;
            if (allY.length > 0) {
                minY = Math.min(minY, Math.min(...allY) - EXTEND_PADDING_Y);
                maxY = Math.max(maxY, Math.max(...allY) + EXTEND_PADDING_Y);
            }
            const displayMinY = Math.floor(minY);
            const displayMaxY = Math.ceil(maxY);

            const datasets = curves.map((c, i) => {
                let points = [{x: c.x1, y: c.y1}, {x: c.x2, y: c.y2}].sort((a, b) => a.x - b.x);
                const left = points[0], right = points[1];
                const data = [];
                for (let t = displayMinX; t <= Math.floor(left.x); t++) data.push({x: t, y: left.y});
                data.push({x: left.x, y: left.y});
                for (let t = Math.ceil(left.x); t < Math.floor(right.x); t++) data.push({x: t, y: getLWTForCurve(c, t)});
                data.push({x: right.x, y: right.y});
                for (let t = Math.ceil(right.x); t <= displayMaxX; t++) data.push({x: t, y: right.y});

                return {
                    label: c.name,
                    data,
                    borderColor: `hsl(${i * 137 % 360}, 70%, 50%)`,
                    backgroundColor: `hsl(${i * 137 % 360}, 70%, 50%)`,
                    fill: false,
                    tension: 0,
                    pointRadius: ctx => (ctx.parsed.x === left.x || ctx.parsed.x === right.x) ? 5 : 0,
                    pointHoverRadius: ctx => (ctx.parsed.x === left.x || ctx.parsed.x === right.x) ? 8 : 4,
                    pointBackgroundColor: `hsl(${i * 137 % 360}, 70%, 50%)`
                };
            });

            const baseAnnotations = {
                vLine: {
                    type: 'line',
                    scaleID: 'x',
                    value: null,
                    borderColor: 'rgba(80, 80, 80, 0.9)',
                    borderWidth: 1.5,
                    borderDash: [6, 4],
                    label: {
                        display: false,
                        content: '',
                        position: 'end',  // Places label just above the X-axis
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        color: '#fff',
                        font: { size: 12, weight: 'bold' },
                        padding: 6,
                        borderRadius: 4
                    }
                }
            };

            curves.forEach((curve, i) => {
                const color = `hsl(${i * 137 % 360}, 70%, 50%)`;
                baseAnnotations[`hLine${i}`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: color,
                    borderWidth: 1.5,
                    borderDash: [6, 4],
                    label: {
                        display: false,
                        content: '',
                        position: 'start',  // Left side, next to Y axis
                        backgroundColor: color,
                        color: '#fff',
                        font: { size: 11, weight: 'bold' },
                        padding: 5,
                        borderRadius: 4
                    }
                };
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        tooltip: { enabled: false },  // Tooltip completely disabled
                        annotation: { annotations: baseAnnotations }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: 'Outdoor Temperature (°C)' },
                            min: displayMinX,
                            max: displayMaxX,
                            ticks: { stepSize: 5 }
                        },
                        y: {
                            title: { display: true, text: 'Leaving Water Temperature (°C)' },
                            min: displayMinY,
                            max: displayMaxY,
                            ticks: { stepSize: 5 }
                        }
                    },
                    onHover: (event, activeElements) => {
                        const chartArea = chart.chartArea;
                        if (!event.native || !chartArea) return;

                        const x = event.x;
                        const y = event.y;

                        if (x < chartArea.left || x > chartArea.right || y < chartArea.top || y > chartArea.bottom) {
                            chart.options.plugins.annotation.annotations.vLine.value = null;
                            chart.options.plugins.annotation.annotations.vLine.label.display = false;
                            curves.forEach((_, i) => {
                                chart.options.plugins.annotation.annotations[`hLine${i}`].value = null;
                                chart.options.plugins.annotation.annotations[`hLine${i}`].label.display = false;
                            });
                            chart.update('none');
                            return;
                        }

                        const xValue = chart.scales.x.getValueForPixel(x);
                        const snappedX = Math.round(xValue);  // Snap to whole °C

                        // Vertical line + label
                        chart.options.plugins.annotation.annotations.vLine.value = snappedX;
                        chart.options.plugins.annotation.annotations.vLine.label.content = `Outdoor temperature: ${snappedX}°C`;
                        chart.options.plugins.annotation.annotations.vLine.label.display = true;

                        // Horizontal lines + labels
                        curves.forEach((curve, i) => {
                            const lwt = getLWTForCurve(curve, snappedX);
                            const roundedY = Math.round(lwt * 10) / 10;
                            const color = `hsl(${i * 137 % 360}, 70%, 50%)`;

                            const hLine = chart.options.plugins.annotation.annotations[`hLine${i}`];
                            hLine.value = roundedY;
                            hLine.borderColor = color;
                            hLine.label.content = `LWT: ${roundedY}°C`;
                            hLine.label.backgroundColor = color;
                            hLine.label.display = true;
                        });

                        chart.update('none');
                    }
                },
                plugins: [{
                    id: 'hideCrosshairOnLeave',
                    afterEvent: (chart, args) => {
                        if (args.event.type === 'mouseout') {
                            chart.options.plugins.annotation.annotations.vLine.value = null;
                            chart.options.plugins.annotation.annotations.vLine.label.display = false;
                            curves.forEach((_, i) => {
                                chart.options.plugins.annotation.annotations[`hLine${i}`].value = null;
                                chart.options.plugins.annotation.annotations[`hLine${i}`].label.display = false;
                            });
                            chart.update('none');
                        }
                    }
                }]
            });
        }

        function updateURL() {
            const base = window.location.pathname;
            const queryParts = [];
            curves.forEach((curve, i) => {
                queryParts.push(`curve${i + 1}=${curve.x1}${SEPARATOR}${curve.y1}${SEPARATOR}${curve.x2}${SEPARATOR}${curve.y2}`);
                queryParts.push(`name${i + 1}=${encodeURIComponent(curve.name)}`);
            });
            const oat = parseFloat(document.getElementById('oat-input').value);
            if (!isNaN(oat)) queryParts.push(`oat=${oat}`);
            queryParts.sort();
            const newQuery = queryParts.join('&');
            history.replaceState(null, '', newQuery ? `${base}?${newQuery}` : base);
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(window.location.href);
                const feedback = document.getElementById('copy-feedback');
                feedback.classList.remove('d-none');
                setTimeout(() => feedback.classList.add('d-none'), 3000);
            } catch (err) {
                alert('Failed to copy link. Please copy it manually from the address bar.');
            }
        }

        function loadFromURL() {
            const search = window.location.search.substring(1);
            if (!search) { addCurve(); return; }
            const params = new URLSearchParams(search);
            const curveKeys = [...params.keys()].filter(k => k.startsWith('curve')).map(k => parseInt(k.match(/curve(\d+)/)[1])).sort((a,b) => a-b);
            if (curveKeys.length === 0) { addCurve(); return; }

            const maxIndex = Math.max(...curveKeys);
            for (let i = 1; i <= maxIndex; i++) {
                const curveParam = params.get(`curve${i}`);
                const nameParam = params.get(`name${i}`);
                if (curveParam) {
                    const [x1, y1, x2, y2] = curveParam.split(SEPARATOR).map(parseFloat);
                    if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
                        addCurve({ x1, y1, x2, y2, name: nameParam ? decodeURIComponent(nameParam) : null });
                    }
                }
            }
            if (params.has('oat')) {
                const oat = parseFloat(params.get('oat'));
                if (!isNaN(oat)) {
                    document.getElementById('oat-input').value = oat;
                    calculateLWT(oat);
                }
            }
        }

        function calculateLWT(oat) {
            const results = document.getElementById('lwt-results');
            results.innerHTML = '';
            if (isNaN(oat)) return;
            curves.forEach(c => {
                const lwt = getLWTForCurve(c, oat);
                const p = document.createElement('p');
                p.textContent = `${c.name}: LWT = ${lwt.toFixed(1)} °C`;
                results.appendChild(p);
            });
        }

        window.addEventListener('load', () => {
            loadFromURL();
            document.getElementById('copy-clipboard').addEventListener('click', copyToClipboard);
        });

        document.getElementById('add-curve').addEventListener('click', () => {
            if (curves.length === 0) addCurve();
            else {
                const last = curves[curves.length - 1];
                addCurve({ x1: last.x1, y1: last.y1 - 5, x2: last.x2, y2: last.y2, name: null });
            }
        });

        document.getElementById('oat-input').addEventListener('input', e => {
            const oat = parseFloat(e.target.value);
            calculateLWT(oat);
            updateURL();
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>