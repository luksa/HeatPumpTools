<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dependent Heating Curve Visualizer</title>
    <link href="bootstrap-custom.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        body { padding: 20px; }
        #chart { max-height: 600px; cursor: crosshair; }
        .header-container { position: relative; }
        .by-line {
            position: absolute;
            bottom: 0;
            right: 0;
            color: #6c757d;
        }
        @media (max-width: 576px) {
            .by-line { position: static; text-align: right; margin-top: 0.5rem; }
        }
        .narrow-input { max-width: 8ch; }
        .lwt-input-group { min-width: 320px; }
        #lwt-results p { margin-bottom: 0.5rem; font-weight: 500; }
        .lwt-row { align-items: flex-start; }
        footer { margin-top: 4rem; text-align: center; color: #6c757d; font-size: 0.85rem; }
        .inputs-column { max-width: 400px; }
        .nav-tabs .nav-link {
            border-bottom-color: transparent;
        }
        .tab-content {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            padding: 1.5rem;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container mb-4">
            <h1 class="d-inline-block">Weather Dependent Heating Curve Visualizer</h1>
            <div class="by-line">
                By <a href="https://github.com/luksa" target="_blank">Marko Lukša</a>
            </div>
        </div>
        <p class="mb-4">
            This tool helps you visualize and fine-tune weather-dependent heating curves for heat pumps.
            Define each curve by two points, add multiple curves for easy comparison, and instantly see the leaving water temperature (LWT)
            for all curves at any chosen outdoor temperature.
        </p>
     
        <div class="row">
            <div class="col-md-4 order-md-1 mb-4 mb-md-0 inputs-column">
                <ul class="nav nav-tabs mb-0" id="curveTabs" role="tablist"></ul>
                <div class="tab-content" id="curveTabContent"></div>
                <button id="add-curve" class="btn btn-primary mt-3">Add Another Curve</button>
            </div>
         
            <div class="col-md-8 order-md-2">
                <div class="d-flex gap-4">
                    <label class="form-label">Display:</label>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-base-curve">
                        <label class="form-check-label" for="show-base-curve">
                            Base Curve
                        </label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-final-lwt">
                        <label class="form-check-label" for="show-final-lwt">
                            Curve with Offsets
                        </label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="show-modulation" disabled>
                        <label class="form-check-label" for="show-modulation">
                            Modulation Steps
                        </label>
                    </div>
                </div>

                <canvas id="chart" class="mb-4"></canvas>
             
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3">What's my LWT at a given outdoor temperature?</h5>
                        <div class="row lwt-row">
                            <div class="col">
                                <div class="input-group lwt-input-group">
                                    <span class="input-group-text">Outdoor Temp</span>
                                    <input id="oat-input" type="number" step="1" class="form-control narrow-input">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                            <div class="col" id="lwt-results"></div>
                        </div>
                    </div>
                </div>
             
                <div class="card">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                            <h5 class="card-title mb-0">Share this curve</h5>
                            <button id="copy-clipboard" class="btn btn-secondary">
                                <i class="fas fa-copy"></i> Copy Link
                            </button>
                        </div>
                        <small id="copy-feedback" class="text-success d-none mt-3 d-block">Link copied to clipboard!</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
        Vibe-coded by <a href="https://github.com/luksa" target="_blank">Marko Lukša</a> with
        <a href="https://grok.com" target="_blank">Grok</a>.
        Inspired by <a href="https://vscope.at/heizkurve" target="_blank">vscope.at/heizkurve</a>.
    </footer>

    <!-- Bootstrap Rename Modal -->
    <div class="modal fade" id="renameModal" tabindex="-1" aria-labelledby="renameModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="renameModalLabel">Rename Curve</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <label for="renameInput" class="form-label">Curve name</label>
                    <input type="text" class="form-control" id="renameInput">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="renameSave">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let curves = [];
        let chart;
        let oat;
        const MOD_STEPS=4;
        const DEFAULT_MIN_X = -10;
        const DEFAULT_MAX_X = 25;
        const DEFAULT_MIN_Y = 20;
        const DEFAULT_MAX_Y = 40;
        const TOP_PADDING    = 5;
        const BOTTOM_PADDING = 5;
        const LEFT_PADDING   = 5;
        const RIGHT_PADDING  = 5;
        const SEPARATOR = ',';

        function roundTo5(num) { return Math.round(num / 5) * 5; }
        function ceilTo5(num)  { return Math.ceil(num  / 5) * 5; }
        function floorTo5(num) { return Math.floor(num / 5) * 5; }

        let renameModal = null;
        let renameInput = null;
        let renameSave  = null;
        let currentRenameIndex = -1;
        let showBaseCurve = false;
        let showFinalLWT = false;
        let showModulation = false;

        const frostBoostPresets = [
            { label: "None",              increase: 0,   span: 0   },
            { label: "2°C, span 4°C",     increase: 2,   span: 4   },
            { label: "4°C, span 4°C",     increase: 4,   span: 4   },
            { label: "2°C, span 8°C",     increase: 2,   span: 8   },
            { label: "4°C, span 8°C",     increase: 4,   span: 8   },
        ];

        const epsilon = 0.1;

        function openRenameModal(index) {
            currentRenameIndex = index;
            renameInput.value = curves[index].name;
            renameModal.show();
            renameModal._element.addEventListener('shown.bs.modal', function handler() {
                renameInput.focus();
                renameInput.select();
                renameModal._element.removeEventListener('shown.bs.modal', handler);
            });
        }

        function saveRename() {
            if (currentRenameIndex === -1) return;
            const newName = renameInput.value.trim() || `Curve ${currentRenameIndex + 1}`;
            curves[currentRenameIndex].name = newName;

            const activeTabButton = document.querySelector('.nav-link.active');
            const activeTabId = activeTabButton?.id;

            updateTabsAndContent();
            updateChart();
            updateURL();
            calculateLWT();

            if (activeTabId) {
                const tabToActivate = document.getElementById(activeTabId);
                if (tabToActivate) new bootstrap.Tab(tabToActivate).show();
            }

            renameModal.hide();
        }

        function updateRemoveButtons() {
            document.querySelectorAll('.remove').forEach(btn => {
                btn.style.display = curves.length === 1 ? 'none' : 'block';
            });
        }

        function validateCurve(curve, pane) {
            const offsetInput    = pane.querySelector('.offset');
            const maxModInput    = pane.querySelector('.max-mod');
            const y1Input        = pane.querySelector('.y1');
            const y2Input        = pane.querySelector('.y2');
            const hminInput      = pane.querySelector('.hmin');
            const hmaxInput      = pane.querySelector('.hmax');

            clearInvalid(offsetInput);
            clearInvalid(maxModInput);
            clearInvalid(y1Input);
            clearInvalid(y2Input);

            const offset   = getNumber(offsetInput.value, 0);
            const maxMod   = getNumber(maxModInput.value, null);
            const hmin     = getNumber(hminInput.value, null);
            const hmax     = getNumber(hmaxInput.value, null);

            if (offset !== 0 && (hmin === null || hmax === null)) {
                markInvalid(offsetInput, 'Please enter the heating minimum and maximum to display the curve correctly.');
            }

            if (hmin !== null || hmax !== null) {
                const effMin = hmin ?? -Infinity;
                const effMax = hmax ?? Infinity;

                if (curve.y1 < effMin || curve.y1 > effMax) {
                    markInvalid(y1Input, 'Leaving water temperature must be within Heating Minimum/Maximum set below.');
                }
                if (curve.y2 < effMin || curve.y2 > effMax) {
                    markInvalid(y2Input, 'Leaving water temperature must be within Heating Minimum/Maximum set below.');
                }
            }
        }

        function markInvalid(input, message) {
            input.classList.add('is-invalid');
            input.setAttribute('title', message);
            input.setAttribute('data-bs-toggle', 'tooltip');
            const tooltip = bootstrap.Tooltip.getOrCreateInstance(input, {trigger: 'hover focus'});
            tooltip.setContent({ '.tooltip-inner': message });
            tooltip.update();
            tooltip.show();
        }

        function clearInvalid(input) {
            input.classList.remove('is-invalid');
            input.removeAttribute('title');
            const tooltip = bootstrap.Tooltip.getInstance(input);
            if (tooltip) tooltip.dispose();
        }

        function updateTabsAndContent() {
            const tabList = document.getElementById('curveTabs');
            const tabContent = document.getElementById('curveTabContent');
            tabList.innerHTML = '';
            tabContent.innerHTML = '';

            curves.forEach((curve, i) => {
                const tabId = `curve-tab-${i}`;
                const li = document.createElement('li');
                li.className = 'nav-item';
                li.innerHTML = `
                    <button class="nav-link ${i === 0 ? 'active' : ''}" 
                            id="${tabId}-tab" 
                            data-bs-toggle="tab" 
                            data-bs-target="#${tabId}" 
                            type="button" role="tab">
                        ${curve.name}
                    </button>`;
                tabList.appendChild(li);

                const pane = document.createElement('div');
                pane.className = `tab-pane fade ${i === 0 ? 'show active' : ''}`;
                pane.id = tabId;
                pane.role = 'tabpanel';
                pane.innerHTML = `
                    <div class="mb-4">
                        <h6 class="fw-bold">Low Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group has-validation">
                                    <input type="number" class="form-control narrow-input y1" value="${curve.y1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x1" value="${curve.x1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4">
                        <h6 class="fw-bold">High Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group has-validation">
                                    <input type="number" class="form-control narrow-input y2" value="${curve.y2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x2" value="${curve.x2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4">
                        <h6 class="fw-bold">Adjustments</h6>
                        <div class="row align-items-center mb-2">
                            <label class="col-sm-7 col-form-label text-sm-end">Offset</label>
                            <div class="col-sm-5">
                                <div class="input-group has-validation">
                                    <input type="number" class="form-control narrow-input offset" value="${curve.offset ?? 0}" step="1" min="-10" max="10">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4">
                        <h6 class="fw-bold">Space Heating Settings</h6>
                        <div class="row align-items-center mb-2">
                            <label class="col-sm-7 col-form-label text-sm-end">Heating Minimum</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input hmin" value="${curve.hmin ?? ''}" placeholder="—" step="1" min="15" max="37">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center mb-2">
                            <label class="col-sm-7 col-form-label text-sm-end">Heating Maximum</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input hmax" value="${curve.hmax ?? ''}" placeholder="—" step="1" min="37" max="60">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center mb-2">
                            <label class="col-sm-7 col-form-label text-sm-end">Modulation</label>
                            <div class="col-sm-5">
                                <div class="input-group has-validation">
                                    <input type="number" class="form-control narrow-input max-mod" value="${curve.maxMod ?? ''}" placeholder="—" step="1" min="0" max="10">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center mb-3">
                            <label class="col-sm-7 col-form-label text-sm-end">Increase around 0°C</label>
                            <div class="col-sm-5">
                                <select class="form-select frost-boost">
                                    ${frostBoostPresets.map((p, idx) => 
                                        `<option value="${idx}" ${curve.frostBoostIdx === idx ? 'selected' : ''}>
                                            ${p.label}
                                        </option>`
                                    ).join('')}
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="d-flex gap-2">
                        <button class="btn btn-primary rename" data-index="${i}">Rename Curve</button>
                        <button class="btn btn-danger remove" data-index="${i}">Remove Curve</button>
                    </div>`;
                tabContent.appendChild(pane);
            });

            document.querySelectorAll('input[type="number"], select.frost-boost').forEach(el => {
                el.removeEventListener('change', updateAll);
                el.removeEventListener('input', updateAll);
                el.addEventListener('change', updateAll);
                el.addEventListener('input', updateAll);
            });

            document.querySelectorAll('.rename').forEach(btn => {
                btn.addEventListener('click', () => openRenameModal(parseInt(btn.dataset.index)));
            });
            document.querySelectorAll('.remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    curves.splice(parseInt(btn.dataset.index), 1);
                    updateTabsAndContent();
                    updateAll();
                });
            });

            updateRemoveButtons();

            curves.forEach((curve, i) => {
                const pane = document.getElementById(`curve-tab-${i}`);
                if (pane) validateCurve(curve, pane);
            });
        }

        function addCurve(data = {
            x1: -5, y1: 45, x2: 20, y2: 25,
            name: null, offset: 0, maxMod: 5,
            hmin: null, hmax: null, frostBoostIdx: 0
        }) {
            const defaultName = `Curve ${curves.length + 1}`;
            curves.push({
                x1: data.x1,
                y1: data.y1,
                x2: data.x2,
                y2: data.y2,
                name: data.name || defaultName,
                offset: data.offset ?? 0,
                maxMod: data.maxMod ?? null,
                hmin: data.hmin ?? null,
                hmax: data.hmax ?? null,
                frostBoostIdx: data.frostBoostIdx ?? 0
            });
            updateTabsAndContent();
            updateAll();

            const newTabBtn = document.querySelector(`#curve-tab-${curves.length - 1}-tab`);
            if (newTabBtn) new bootstrap.Tab(newTabBtn).show();
        }

        function getNumber(val, def = null) {
            if (val === "" || val == null) return def;
            const n = parseFloat(val);
            return isNaN(n) ? def : n;
        }

        function updateAll() {
            const activePane = document.querySelector('.tab-pane.active');
            if (!activePane) return;

            const index = Array.from(document.querySelectorAll('.tab-pane')).indexOf(activePane);
            if (index < 0 || index >= curves.length) return;

            const curve = curves[index];

            curve.y1     = getNumber(activePane.querySelector('.y1')?.value, curve.y1);
            curve.x1     = getNumber(activePane.querySelector('.x1')?.value, curve.x1);
            curve.y2     = getNumber(activePane.querySelector('.y2')?.value, curve.y2);
            curve.x2     = getNumber(activePane.querySelector('.x2')?.value, curve.x2);

            curve.offset    = getNumber(activePane.querySelector('.offset')?.value, 0);
            curve.maxMod    = getNumber(activePane.querySelector('.max-mod')?.value, null);
            curve.hmin      = getNumber(activePane.querySelector('.hmin')?.value, null);
            curve.hmax      = getNumber(activePane.querySelector('.hmax')?.value, null);
            curve.frostBoostIdx = getNumber(activePane.querySelector('.frost-boost')?.value, 0);

            validateCurve(curve, activePane);

            updateChart();
            updateURL();
            calculateLWT();
            displayDefaultCrosshair();
        }

        function getFrostBoostAdd(curve, oat) {
            const preset = frostBoostPresets[curve.frostBoostIdx || 0];
            if (!preset || preset.increase <= 0 || preset.span <= 0) return 0;
            const half = preset.span / 2;
            if (oat >= -half && oat <= half) return preset.increase;
            return 0;
        }

        function getModulationOffset(curve, modStep = 0) {
            if (curve.maxMod == null || modStep == null || modStep == 0) return 0;
            return (curve.maxMod / MOD_STEPS) * modStep;
        }

        function getLWTForCurve(curve, oat, addIncreaseAroundZero = false, addOffset = false, modStep = 0) {
            let points = [{x: curve.x1, y: curve.y1}, {x: curve.x2, y: curve.y2}].sort((a, b) => a.x - b.x);
            const left = points[0];
            const right = points[1];

            let baseLWT;
            if (oat <= left.x) baseLWT = left.y;
            else if (oat >= right.x) baseLWT = right.y;
            else {
                const slope = (right.y - left.y) / (right.x - left.x);
                baseLWT = left.y + slope * (oat - left.x);
            }

            let adjustment = 0;
            if (addIncreaseAroundZero) adjustment += getFrostBoostAdd(curve, oat);
            if (addOffset) adjustment += curve.offset || 0;
            adjustment += getModulationOffset(curve, modStep);

            let lwt = baseLWT + adjustment;

            if (curve.hmin != null) lwt = Math.max(lwt, curve.hmin);
            if (curve.hmax != null) lwt = Math.min(lwt, curve.hmax);

            return lwt;
        }

        function updateChart() {
            if (chart) chart.destroy();
            const ctx = document.getElementById('chart').getContext('2d');

            let allX = [];
            curves.forEach(c => {
                allX.push(c.x1, c.x2);
            });

            const minX = allX.length ? Math.min(...allX) : DEFAULT_MIN_X;
            const maxX = allX.length ? Math.max(...allX) : DEFAULT_MAX_X;
            const displayMinX = floorTo5(minX - LEFT_PADDING);
            const displayMaxX = ceilTo5(maxX + RIGHT_PADDING);

            let specialX = [];
            curves.forEach(c => {
                specialX.push(c.x1, c.x2);
                if (c.frostBoostIdx > 0) {
                    const preset = frostBoostPresets[c.frostBoostIdx];
                    if (preset.increase > 0) {
                        const half = preset.span / 2;
                        specialX.push(-half - epsilon, -half, half, half + epsilon);
                    }
                }
            });

            let xs = [];
            for (let t = Math.floor(displayMinX); t <= Math.ceil(displayMaxX); t++) {
                xs.push(t);
            }
            xs = [...xs, ...specialX];
            xs = [...new Set(xs)].sort((a, b) => a - b);

            let allY = [];
            let allModulationY = [];
            curves.forEach(c => {
                if (showBaseCurve) {
                    xs.forEach(x => allY.push(getLWTForCurve(c, x)));
                }
                if (showFinalLWT) {
                    xs.forEach(x => allY.push(getLWTForCurve(c, x, true, true)));
                }
                if (showModulation) {
                    xs.forEach(x => allModulationY.push(getLWTForCurve(c, x, true, true, -MOD_STEPS)));
                    xs.forEach(x => allModulationY.push(getLWTForCurve(c, x, true, true, MOD_STEPS)));
                }
            });

            const rawMinY = allY.length ? Math.min(...allY) : DEFAULT_MIN_Y;
            const rawMaxY = allY.length ? Math.max(...allY) : DEFAULT_MAX_Y;
            const rawModulationMinY = allModulationY.length ? Math.min(...allModulationY) : Infinity;
            const rawModulationMaxY = allModulationY.length ? Math.max(...allModulationY) : -Infinity;

            const displayMinY = floorTo5(Math.min(rawMinY - BOTTOM_PADDING, rawModulationMinY));
            const displayMaxY = ceilTo5(Math.max(rawMaxY + TOP_PADDING, rawModulationMaxY));

            const datasets = [];

            curves.forEach((c, i) => {
                const hue = i * 137 % 360;
                const baseColor = `hsl(${hue}, 70%, 50%)`;
                const dimColor = `hsl(${hue}, 70%, 95%)`;
                const modulationColors = [
                    baseColor,
                    `hsl(${hue}, 70%, 75%)`, 
                    `hsl(${hue}, 70%, 80%)`, 
                    `hsl(${hue}, 70%, 85%)`, 
                    `hsl(${hue}, 70%, 90%)`]

                const hasOffsetAdj = c.offset !== 0;
                const hasFrostAdj = c.frostBoostIdx > 0;
                const hasAnyAdj = hasOffsetAdj || hasFrostAdj;
                if (showBaseCurve) {
                    datasets.push({
                        label: c.name,
                        data: xs.map(x => ({x, y: getLWTForCurve(c, x)})),
                        borderColor: baseColor,
                        backgroundColor: baseColor,
                        borderWidth: 3,
                        borderDash: [],
                        tension: 0,
                        pointRadius: ctx => {
                            const xVal = ctx.parsed.x;
                            return (Math.abs(xVal - c.x1) < epsilon || Math.abs(xVal - c.x2) < epsilon) ? 6 : 0;
                        }
                    });
                }

                if (showFinalLWT || showModulation) {
                    datasets.push({
                        label: `With offsets`,
                        data: xs.map(x => ({x, y: getLWTForCurve(c, x, true, true)})),
                        borderColor: baseColor,
                        borderWidth: 2,
                        borderDash: [],
                        tension: 0,
                        pointRadius: 0
                    });
                }

                if (showModulation && c.maxMod) {
                    for (modStep = -MOD_STEPS; modStep <= MOD_STEPS; modStep++) {
                        if (modStep === 0) continue;    // already drawn above
                        datasets.push({
                            label: modStep == 2 ? `Modulation` : `Hidden in legend`,
                            data: xs.map(x => ({x, y: getLWTForCurve(c, x, true, true, modStep)})),
                            borderColor: modulationColors[Math.abs(modStep)],
                            backgroundColor: modulationColors[Math.abs(modStep)],
                            borderWidth: 1,
                            borderDash: [],
                            tension: 0,
                            pointRadius: 0,
                            hoverRadius: 0
                        });
                    }
                }
            });

            const baseAnnotations = {
                vLine: {
                    type: 'line',
                    scaleID: 'x',
                    value: null,
                    borderColor: 'rgba(80,80,80,0.9)',
                    borderWidth: 1.5,
                    borderDash: [6,4],
                    label: { display: false, content: '', position: 'end', backgroundColor: 'rgba(0,0,0,0.8)', color: '#fff', font: {size:12, weight:'bold'}, padding:6, borderRadius:4 }
                }
            };

            curves.forEach((c, i) => {
                const hue = i * 137 % 360;
                baseAnnotations[`hLine${i}_base`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: `hsl(${hue}, 70%, 60%)`,
                    borderWidth: 1.5,
                    borderDash: [6,4],
                    label: { display: false, content: '', position: 'start', backgroundColor: `hsl(${hue}, 70%, 60%)`, color: '#fff', font: {size:11, weight:'bold'}, padding:5, borderRadius:4 }
                };
                baseAnnotations[`hLine${i}_offset`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: `hsl(${hue}, 70%, 60%)`,
                    borderWidth: 1.5,
                    borderDash: [6,4],
                    label: { display: false, content: '', position: 'start', backgroundColor: `hsl(${hue}, 70%, 60%)`, color: '#fff', font: {size:11, weight:'bold'}, padding:5, borderRadius:4 }
                };
                baseAnnotations[`hLine${i}_maxmod`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: `hsl(${hue}, 70%, 60%)`,
                    borderWidth: 1.5,
                    borderDash: [6,4],
                    label: { display: false, content: '', position: 'start', backgroundColor: `hsl(${hue}, 70%, 60%)`, color: '#fff', font: {size:11, weight:'bold'}, padding:5, borderRadius:4 }
                };
                baseAnnotations[`hLine${i}_minmod`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: `hsl(${hue}, 70%, 50%)`,
                    borderWidth: 1.5,
                    borderDash: [10,4],
                    label: { display: false, content: '', position: 'start', backgroundColor: `hsl(${hue}, 70%, 50%)`, color: '#fff', font: {size:11, weight:'bold'}, padding:5, borderRadius:4 }
                };
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    animation: false,
                    interaction: { mode: 'nearest', intersect: false, axis: 'x' },
                    plugins: {
                        tooltip: { enabled: false },
                        legend: { 
                            position: 'top', 
                            labels: { 
                                usePointStyle: false, 
                                boxWidth: 20, 
                                boxHeight: 0,
                                filter: (legendItem, chartData) => {
                                    return (legendItem.text !== 'Hidden in legend');
                                }
                            }
                        },
                        annotation: { annotations: baseAnnotations }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: 'Outdoor Temperature (°C)' },
                            min: displayMinX,
                            max: displayMaxX,
                            ticks: { stepSize: 5 }
                        },
                        y: {
                            title: { display: true, text: 'Leaving Water Temperature (°C)' },
                            min: displayMinY,
                            max: displayMaxY,
                            ticks: { stepSize: 5 }
                        }
                    },
                    onHover: (event, activeElements) => {

                        const area = chart.chartArea;
                        if (!event.native || !area) return;
                        const x = event.x, y = event.y;
                        if (x < area.left || x > area.right || y < area.top || y > area.bottom) {
                            displayDefaultCrosshair();
                            return;
                        }
                        const xVal = chart.scales.x.getValueForPixel(x);

                        let snapped;
                        if (activeElements.length > 0) {
                            let minDist = Infinity;
                            let chosenX = null;
                            activeElements.forEach(ae => {
                                const px = chart.scales.x.getValueForPixel(ae.element.x);
                                const dist = Math.abs(px - xVal);
                                if (dist < minDist) {
                                    minDist = dist;
                                    chosenX = px;
                                } else if (dist === minDist) {
                                    if (px > chosenX) chosenX = px;  // Prefer the larger x in case of ties
                                }
                            });
                            snapped = chosenX;
                        } else {
                            snapped = Math.round(xVal);
                        }
                        displayCrosshair(snapped);
                    }
                },
                plugins: [{
                    id: 'hideCrosshairOnLeave',
                    afterEvent: (ch, args) => {
                        if (args.event.type === 'mouseout') displayDefaultCrosshair();
                    }
                }]
            });
        }

        function displayDefaultCrosshair() {
            displayCrosshair(oat);
        }

        function displayCrosshair(oatVal) {
            if (isNaN(oatVal)) {
                chart.options.plugins.annotation.annotations.vLine.value = null;
                chart.options.plugins.annotation.annotations.vLine.label.display = false;
                curves.forEach((_, i) => {
                    ["_base", "_offset", "_maxmod"].forEach(suffix => {
                         const h = chart.options.plugins.annotation.annotations[`hLine${i}${suffix}`];
                         if (!h) return;
                         h.value = null;
                         h.label.display = false;
                    });
                });
                chart.update('none');
                return;
            }

            chart.options.plugins.annotation.annotations.vLine.value = oatVal;
            chart.options.plugins.annotation.annotations.vLine.label.content = `Outdoor: ${oatVal.toFixed(1)} °C`;
            chart.options.plugins.annotation.annotations.vLine.label.display = true;

            curves.forEach((c, i) => {
                if (showBaseCurve) {
                    let lwt = getLWTForCurve(c, oatVal, true);
                    let rounded = Math.round(lwt * 10) / 10;
                    let h = chart.options.plugins.annotation.annotations[`hLine${i}_base`];
                    h.value = rounded;
                    h.label.content = `LWT from curve: ${rounded} °C`;
                    h.label.display = true;
                }
                if (showFinalLWT || (showModulation && c.maxMod)) {
                    lwt = getLWTForCurve(c, oatVal, true, true);
                    rounded = Math.round(lwt * 10) / 10;
                    h = chart.options.plugins.annotation.annotations[`hLine${i}_offset`];
                    h.value = rounded;
                    h.label.content = (showFinalLWT ? "With offsets" : "No modulation") + `: ${rounded} °C`;
                    h.label.display = true;
                }
                if (showModulation && c.maxMod) {
                    lwt = getLWTForCurve(c, oatVal, true, true, 4);
                    rounded = Math.round(lwt * 10) / 10;
                    h = chart.options.plugins.annotation.annotations[`hLine${i}_maxmod`];
                    h.value = rounded;
                    h.label.content = `With max mod.: ${rounded} °C`;
                    h.label.display = true;
                }
            });

            chart.update('none');
        }

        function updateURL() {
            const parts = [];
            curves.forEach((c, i) => {
                let curveStr = `${c.x1}${SEPARATOR}${c.y1}${SEPARATOR}${c.x2}${SEPARATOR}${c.y2}`;
                const hasExtra = c.offset !== 0 || c.maxMod != null || c.hmin != null || c.hmax != null || c.frostBoostIdx > 0;
                if (hasExtra) {
                    curveStr += `${SEPARATOR}${c.offset}`;
                    curveStr += `${SEPARATOR}0`;
                    curveStr += `${SEPARATOR}${c.maxMod ?? ''}`;
                    curveStr += `${SEPARATOR}${c.hmin ?? ''}${SEPARATOR}${c.hmax ?? ''}${SEPARATOR}${c.frostBoostIdx ?? 0}`;
                }
                parts.push(`curve${i+1}=${curveStr}`);
                parts.push(`name${i+1}=${encodeURIComponent(c.name)}`);
            });
            if (!isNaN(oat)) parts.push(`oat=${oat}`);

            const showParts = [];
            if (showBaseCurve)   showParts.push('base');
            if (showFinalLWT)    showParts.push('final');
            if (showModulation)  showParts.push('mod');
            if (!showBaseCurve || !showFinalLWT || showModulation) {
                parts.push("show=" + showParts.join(','));
            }

            parts.sort();
            const query = parts.join('&');
            const newUrl = query ? `?${query}` : '';
            history.replaceState(null, '', window.location.pathname + newUrl);
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(window.location.href);
                const fb = document.getElementById('copy-feedback');
                fb.classList.remove('d-none');
                setTimeout(() => fb.classList.add('d-none'), 3000);
            } catch {
                alert('Failed to copy. Please copy URL manually.');
            }
        }

        function loadFromURL() {
            const params = new URLSearchParams(window.location.search.substring(1));
            if (params.has('oat')) {
                oat = parseFloat(params.get('oat'));
            }

            const showParam = params.get('show') || 'base,final';
            showBaseCurve   = showParam.includes('base');
            showFinalLWT    = showParam.includes('final');
            showModulation  = showParam.includes('mod');

            const curveKeys = [...params.keys()]
                .filter(k => k.startsWith('curve'))
                .map(k => parseInt(k.match(/curve(\d+)/)?.[1] ?? -1))
                .filter(n => n >= 1)
                .sort((a,b)=>a-b);

            if (curveKeys.length === 0) {
                addCurve();
            }

            const maxIdx = Math.max(...curveKeys);
            for (let i = 1; i <= maxIdx; i++) {
                const curveParam = params.get(`curve${i}`);
                if (!curveParam) continue;

                const parts = curveParam.split(SEPARATOR).map(s => s.trim());
                if (parts.length < 4) continue;

                const [x1s, y1s, x2s, y2s, ...rest] = parts;
                const x1 = parseFloat(x1s);
                const y1 = parseFloat(y1s);
                const x2 = parseFloat(x2s);
                const y2 = parseFloat(y2s);

                if ([x1,y1,x2,y2].some(isNaN)) continue;

                let offset = 0, maxMod = null, hmin = null, hmax = null, frostBoostIdx = 0;
                if (rest.length >= 1) offset    = parseFloat(rest[0]) || 0;
                // rest[1] used to be modStep, but was removed
                if (rest.length >= 3) maxMod    = rest[2] ? parseFloat(rest[2]) : null;
                if (rest.length >= 5) {
                    hmin = rest[3] ? parseFloat(rest[3]) : null;
                    hmax = rest[4] ? parseFloat(rest[4]) : null;
                }
                if (rest.length >= 6) {
                    frostBoostIdx = parseInt(rest[5]) || 0;
                    if (frostBoostIdx < 0 || frostBoostIdx >= frostBoostPresets.length) frostBoostIdx = 0;
                }

                const name = params.has(`name${i}`) ? decodeURIComponent(params.get(`name${i}`)) : null;

                addCurve({x1, y1, x2, y2, name, offset, maxMod, hmin, hmax, frostBoostIdx});
            }

            if (!isNaN(oat)) {
                document.getElementById('oat-input').value = oat;
                calculateLWT();
                displayDefaultCrosshair();
            }

            document.getElementById('show-base-curve').checked = showBaseCurve;
            document.getElementById('show-final-lwt').checked = showFinalLWT;
            document.getElementById('show-modulation').checked = !showFinalLWT && showModulation;
            document.getElementById('show-modulation').disabled = !showFinalLWT;
        }   

        function calculateLWT() {
            const container = document.getElementById('lwt-results');
            container.innerHTML = '';
            if (isNaN(oat)) return;

            curves.forEach(c => {
                const lwt = getLWTForCurve(c, oat, true, true);
                const p = document.createElement('p');
                p.textContent = `${c.name}: LWT = ${lwt.toFixed(1)} °C`;
                container.appendChild(p);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            renameModal = new bootstrap.Modal(document.getElementById('renameModal'));
            renameInput = document.getElementById('renameInput');
            renameSave  = document.getElementById('renameSave');

            renameSave.addEventListener('click', saveRename);
            renameInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                }
            });

            loadFromURL();

            document.getElementById('copy-clipboard').addEventListener('click', copyToClipboard);
            document.getElementById('add-curve').addEventListener('click', () => {
                if (curves.length === 0) {
                    addCurve();
                } else {
                    const last = curves[curves.length - 1];
                    addCurve({
                        x1: last.x1, y1: last.y1 - 5,
                        x2: last.x2, y2: last.y2,
                        offset: last.offset,
                        maxMod: last.maxMod,
                        hmin: last.hmin,
                        hmax: last.hmax,
                        frostBoostIdx: last.frostBoostIdx
                    });
                }
            });

            document.getElementById('oat-input').addEventListener('input', e => {
                oat = parseFloat(e.target.value);
                calculateLWT();
                displayDefaultCrosshair();
                updateURL();
            });

            document.getElementById('show-base-curve').addEventListener('change', e => {
                showBaseCurve = e.target.checked;
                updateChart();
                displayDefaultCrosshair();
                updateURL();
            });
            document.getElementById('show-final-lwt').addEventListener('change', e => {
                showFinalLWT = e.target.checked;
                document.getElementById('show-modulation').disabled = !showFinalLWT;
                if (!showFinalLWT) {
                    showModulation = false;
                    document.getElementById('show-modulation').checked = false;
                }
                updateChart();
                displayDefaultCrosshair();
                updateURL();
            });
            document.getElementById('show-modulation').addEventListener('change', e => {
                showModulation = e.target.checked;
                updateChart();
                displayDefaultCrosshair();
                updateURL();
            });
            
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>