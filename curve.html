<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dependent Heating Curve Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        body { padding: 20px; }
        #chart { max-height: 600px; cursor: crosshair; }
        .header-container { position: relative; }
        .by-line {
            position: absolute;
            bottom: 0;
            right: 0;
            color: #6c757d;
        }
        @media (max-width: 576px) {
            .by-line { position: static; text-align: right; margin-top: 0.5rem; }
        }
        .narrow-input { max-width: 8ch; }
        .lwt-input-group { min-width: 320px; }
        #lwt-results p { margin-bottom: 0.5rem; font-weight: 500; }
        .lwt-row { align-items: flex-start; }
        footer { margin-top: 4rem; text-align: center; color: #6c757d; font-size: 0.85rem; }
        .inputs-column { max-width: 400px; }
        /* Proper tab connection */
        .nav-tabs .nav-link {
            border-bottom-color: transparent;
        }
        .tab-content {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            padding: 1.5rem;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container mb-4">
            <h1 class="d-inline-block">Weather Dependent Heating Curve Visualizer</h1>
            <div class="by-line">
                By <a href="https://github.com/luksa" target="_blank">Marko Lukša</a>
            </div>
        </div>
        <p class="mb-4">
            This tool helps you visualize and fine-tune weather-dependent heating curves for heat pumps.
            Define each curve by two points, add multiple curves for easy comparison, and instantly see the leaving water temperature (LWT)
            for all curves at any chosen outdoor temperature.
        </p>
     
        <div class="row">
            <div class="col-md-4 order-md-1 mb-4 mb-md-0 inputs-column">
                <ul class="nav nav-tabs mb-0" id="curveTabs" role="tablist"></ul>
                <div class="tab-content" id="curveTabContent"></div>
                <button id="add-curve" class="btn btn-primary mt-3">Add Another Curve</button>
            </div>
         
            <div class="col-md-8 order-md-2">
                <canvas id="chart" class="mb-4"></canvas>
             
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3">What's my LWT at a given outdoor temperature?</h5>
                        <div class="row lwt-row">
                            <div class="col">
                                <div class="input-group lwt-input-group">
                                    <span class="input-group-text">Outdoor Temp</span>
                                    <input id="oat-input" type="number" step="1" class="form-control narrow-input">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                            <div class="col" id="lwt-results"></div>
                        </div>
                    </div>
                </div>
             
                <div class="card">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                            <h5 class="card-title mb-0">Share this curve</h5>
                            <button id="copy-clipboard" class="btn btn-secondary">
                                <i class="fas fa-copy"></i> Copy Link
                            </button>
                        </div>
                        <small id="copy-feedback" class="text-success d-none mt-3 d-block">Link copied to clipboard!</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
        Vibe-coded by <a href="https://github.com/luksa" target="_blank">Marko Lukša</a> with
        <a href="https://grok.com" target="_blank">Grok</a>.
        Inspired by <a href="https://vscope.at/heizkurve" target="_blank">vscope.at/heizkurve</a>.
    </footer>

    <!-- Bootstrap Rename Modal -->
    <div class="modal fade" id="renameModal" tabindex="-1" aria-labelledby="renameModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="renameModalLabel">Rename Curve</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <label for="renameInput" class="form-label">Curve name</label>
                    <input type="text" class="form-control" id="renameInput">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="renameSave">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let curves = [];
        let chart;
        let oat;
        const DEFAULT_MIN_X = -10;
        const DEFAULT_MAX_X = 25;
        const DEFAULT_MIN_Y = 20;
        const DEFAULT_MAX_Y = 40;
        const TOP_PADDING = 5;
        const BOTTOM_PADDING = 5;
        const LEFT_PADDING = 5;
        const RIGHT_PADDING = 5;
        const SEPARATOR = ',';

        function roundTo5(num) { return Math.round(num / 5) * 5; }
        function ceilTo5(num) { return Math.ceil(num / 5) * 5; }
        function floorTo5(num) { return Math.floor(num / 5) * 5; }

        let renameModal = null;
        let renameInput = null;
        let renameSave = null;
        let currentRenameIndex = -1;

        function openRenameModal(index) {
            currentRenameIndex = index;
            renameInput.value = curves[index].name;
            renameModal.show();
            renameModal._element.addEventListener('shown.bs.modal', function handler() {
                renameInput.focus();
                renameInput.select();
                renameModal._element.removeEventListener('shown.bs.modal', handler);
            });
        }

        function saveRename() {
            if (currentRenameIndex === -1) return;
            const newName = renameInput.value.trim() || `Curve ${currentRenameIndex + 1}`;
            curves[currentRenameIndex].name = newName;

            const activeTabButton = document.querySelector('.nav-link.active');
            const activeTabId = activeTabButton?.id;

            updateTabsAndContent();
            updateChart();
            updateURL();
            calculateLWT();

            // restore previously active tab
            if (activeTabId) {
                const tabToActivate = document.getElementById(activeTabId);
                if (tabToActivate) {
                    const bsTab = new bootstrap.Tab(tabToActivate);
                    bsTab.show();
                }
            }

            renameModal.hide();
        }

        function updateRemoveButtons() {
            document.querySelectorAll('.remove').forEach(btn => {
                btn.style.display = curves.length === 1 ? 'none' : 'block';
            });
        }

        function updateTabsAndContent() {
            const tabList = document.getElementById('curveTabs');
            const tabContent = document.getElementById('curveTabContent');
            tabList.innerHTML = '';
            tabContent.innerHTML = '';

            curves.forEach((curve, i) => {
                const tabId = `curve-tab-${i}`;
                const li = document.createElement('li');
                li.className = 'nav-item';
                li.role = 'presentation';
                li.innerHTML = `
                    <button class="nav-link ${i === 0 ? 'active' : ''}" 
                            id="${tabId}-tab" 
                            data-bs-toggle="tab" 
                            data-bs-target="#${tabId}" 
                            type="button" role="tab">
                        ${curve.name}
                    </button>`;
                tabList.appendChild(li);

                const pane = document.createElement('div');
                pane.className = `tab-pane fade ${i === 0 ? 'show active' : ''}`;
                pane.id = tabId;
                pane.role = 'tabpanel';
                pane.innerHTML = `
                    <div class="mb-4">
                        <h6 class="fw-bold">Low Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input y1" value="${curve.y1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x1" value="${curve.x1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4">
                        <h6 class="fw-bold">High Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input y2" value="${curve.y2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x2" value="${curve.x2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-primary rename" data-index="${i}">Rename Curve</button>
                        <button class="btn btn-danger remove" data-index="${i}">Remove Curve</button>
                    </div>`;
                tabContent.appendChild(pane);
            });

            document.querySelectorAll('input[type="number"]').forEach(input => {
                input.removeEventListener('change', updateAll);
                input.addEventListener('change', updateAll);
            });
            document.querySelectorAll('.rename').forEach(btn => {
                btn.addEventListener('click', () => openRenameModal(parseInt(btn.dataset.index)));
            });
            document.querySelectorAll('.remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    curves.splice(parseInt(btn.dataset.index), 1);
                    updateTabsAndContent();
                    updateAll();
                });
            });

            updateRemoveButtons();
        }

        function addCurve(data = {x1: -5, y1: 45, x2: 20, y2: 25, name: null}) {
            const defaultName = `Curve ${curves.length + 1}`;
            curves.push({
                x1: data.x1,
                y1: data.y1,
                x2: data.x2,
                y2: data.y2,
                name: data.name || defaultName
            });
            updateTabsAndContent();
            updateAll();

            const newTabBtn = document.querySelector(`#curve-tab-${curves.length - 1}-tab`);
            if (newTabBtn) {
                const bsTab = new bootstrap.Tab(newTabBtn);
                bsTab.show();
            }
        }

        function getNumber(input, defaultValue) {
          if (input) {
            const n = parseFloat(input);
            return isNaN(n) ? defaultValue : n;
          }
          return defaultValue;
        }

        function updateAll() {
            const activePane = document.querySelector('.tab-pane.active');
            if (!activePane) return;

            // Find the index of the active curve
            const index = Array.from(document.querySelectorAll('.tab-pane')).indexOf(activePane);
            if (index < 0 || index >= curves.length) return;

            const curve = curves[index];

            // Use specific classes to select inputs, regardless of DOM order
            const y1Input = activePane.querySelector('.y1');
            const x1Input = activePane.querySelector('.x1');
            const y2Input = activePane.querySelector('.y2');
            const x2Input = activePane.querySelector('.x2');

            // Update values only if inputs exist and have valid numbers
            curve.y1 = getNumber(y1Input.value, curve.y1);
            curve.x1 = getNumber(x1Input.value, curve.x1);
            curve.y2 = getNumber(y2Input.value, curve.y2);
            curve.x2 = getNumber(x2Input.value, curve.x2);

            updateChart();
            updateURL();
            calculateLWT();
            displayDefaultCrosshair();
        }

        function getLWTForCurve(curve, oat) {
            let points = [{x: curve.x1, y: curve.y1}, {x: curve.x2, y: curve.y2}].sort((a, b) => a.x - b.x);
            const left = points[0];
            const right = points[1];
            if (oat <= left.x) return left.y;
            if (oat >= right.x) return right.y;
            const slope = (right.y - left.y) / (right.x - left.x);
            return left.y + slope * (oat - left.x);
        }

        function updateChart() {
            if (chart) chart.destroy();
            const ctx = document.getElementById('chart').getContext('2d');
            let allX1 = [], allX2 = [], allY = [];
            curves.forEach(c => {
                allX1.push(c.x1);
                allX2.push(c.x2);
                allY.push(c.y1, c.y2);
            });
            let minLeft = allX1.length > 0 ? Math.min(...allX1) : DEFAULT_MIN_X;
            let displayMinX = floorTo5(minLeft - LEFT_PADDING);
            let maxRight = allX2.length > 0 ? Math.max(...allX2) : DEFAULT_MAX_X;
            let displayMaxX = ceilTo5(maxRight + RIGHT_PADDING);
            let rawMinY = allY.length > 0 ? Math.min(...allY) : DEFAULT_MIN_Y;
            let rawMaxY = allY.length > 0 ? Math.max(...allY) : DEFAULT_MAX_Y;
            let displayMinY = floorTo5(rawMinY - BOTTOM_PADDING);
            let displayMaxY = floorTo5(rawMaxY) + TOP_PADDING;

            const datasets = curves.map((c, i) => {
                let points = [{x: c.x1, y: c.y1}, {x: c.x2, y: c.y2}].sort((a, b) => a.x - b.x);
                const left = points[0], right = points[1];
                const data = [];
                for (let t = displayMinX; t <= Math.floor(left.x); t++) data.push({x: t, y: left.y});
                data.push({x: left.x, y: left.y});
                for (let t = Math.ceil(left.x); t < Math.floor(right.x); t++) data.push({x: t, y: getLWTForCurve(c, t)});
                data.push({x: right.x, y: right.y});
                for (let t = Math.ceil(right.x); t <= displayMaxX; t++) data.push({x: t, y: right.y});
                return {
                    label: c.name,
                    data,
                    borderColor: `hsl(${i * 137 % 360}, 70%, 50%)`,
                    backgroundColor: `hsl(${i * 137 % 360}, 70%, 50%)`,
                    fill: false,
                    tension: 0,
                    pointRadius: ctx => (ctx.parsed.x === left.x || ctx.parsed.x === right.x) ? 5 : 0,
                    pointHoverRadius: ctx => (ctx.parsed.x === left.x || ctx.parsed.x === right.x) ? 8 : 4,
                    pointBackgroundColor: `hsl(${i * 137 % 360}, 70%, 50%)`
                };
            });

            const baseAnnotations = {
                vLine: {
                    type: 'line',
                    scaleID: 'x',
                    value: null,
                    borderColor: 'rgba(80, 80, 80, 0.9)',
                    borderWidth: 1.5,
                    borderDash: [6, 4],
                    label: { display: false, content: '', position: 'end', backgroundColor: 'rgba(0,0,0,0.8)', color: '#fff', font: { size: 12, weight: 'bold' }, padding: 6, borderRadius: 4 }
                }
            };
            curves.forEach((curve, i) => {
                const color = `hsl(${i * 137 % 360}, 70%, 50%)`;
                baseAnnotations[`hLine${i}`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: color,
                    borderWidth: 1.5,
                    borderDash: [6, 4],
                    label: { display: false, content: '', position: 'start', backgroundColor: color, color: '#fff', font: { size: 11, weight: 'bold' }, padding: 5, borderRadius: 4 }
                };
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        tooltip: { enabled: false },
                        annotation: { annotations: baseAnnotations }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: 'Outdoor Temperature (°C)' },
                            min: displayMinX,
                            max: displayMaxX,
                            ticks: { stepSize: 5 }
                        },
                        y: {
                            title: { display: true, text: 'Leaving Water Temperature (°C)' },
                            min: displayMinY,
                            max: displayMaxY,
                            ticks: { stepSize: 5 }
                        }
                    },
                    onHover: (event, activeElements) => {
                        const chartArea = chart.chartArea;
                        if (!event.native || !chartArea) return;
                        const x = event.x;
                        const y = event.y;
                        if (x < chartArea.left || x > chartArea.right || y < chartArea.top || y > chartArea.bottom) {
                            displayDefaultCrosshair();
                            return;
                        }
                        const xValue = chart.scales.x.getValueForPixel(x);
                        const snappedX = Math.round(xValue);
                        displayCrosshair(snappedX);
                    }
                },
                plugins: [{
                    id: 'hideCrosshairOnLeave',
                    afterEvent: (chart, args) => {
                        if (args.event.type === 'mouseout') {
                            displayDefaultCrosshair();
                        }
                    }
                }]
            });
        }

        function displayDefaultCrosshair() {
            displayCrosshair(oat);
        }

        function displayCrosshair(oat) {
            if (oat === NaN) {
                chart.options.plugins.annotation.annotations.vLine.value = null;
                chart.options.plugins.annotation.annotations.vLine.label.display = false;
                curves.forEach((_, i) => {
                    chart.options.plugins.annotation.annotations[`hLine${i}`].value = null;
                        chart.options.plugins.annotation.annotations[`hLine${i}`].label.display = false;
                });
                chart.update('none');
                return;
            }

            chart.options.plugins.annotation.annotations.vLine.value = oat;
            chart.options.plugins.annotation.annotations.vLine.label.content = `Outdoor temperature: ${oat}°C`;
            chart.options.plugins.annotation.annotations.vLine.label.display = true;
            curves.forEach((curve, i) => {
                const lwt = getLWTForCurve(curve, oat);
                const roundedY = Math.round(lwt * 10) / 10;
                const color = `hsl(${i * 137 % 360}, 70%, 50%)`;
                const hLine = chart.options.plugins.annotation.annotations[`hLine${i}`];
                hLine.value = roundedY;
                hLine.borderColor = color;
                hLine.label.content = `LWT: ${roundedY}°C`;
                hLine.label.backgroundColor = color;
                hLine.label.display = true;
            });
            chart.update('none');
        }

        function updateURL() {
            const base = window.location.pathname;
            const queryParts = [];
            curves.forEach((curve, i) => {
                queryParts.push(`curve${i + 1}=${curve.x1}${SEPARATOR}${curve.y1}${SEPARATOR}${curve.x2}${SEPARATOR}${curve.y2}`);
                queryParts.push(`name${i + 1}=${encodeURIComponent(curve.name)}`);
            });

            if (!isNaN(oat)) queryParts.push(`oat=${oat}`);
            queryParts.sort();
            const newQuery = queryParts.join('&');
            history.replaceState(null, '', newQuery ? `${base}?${newQuery}` : base);
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(window.location.href);
                const feedback = document.getElementById('copy-feedback');
                feedback.classList.remove('d-none');
                setTimeout(() => feedback.classList.add('d-none'), 3000);
            } catch (err) {
                alert('Failed to copy link. Please copy it manually from the address bar.');
            }
        }

        function loadFromURL() {
            const search = window.location.search.substring(1);
            if (!search) { addCurve(); return; }

            const params = new URLSearchParams(search);

            if (params.has('oat')) {
                oat = parseFloat(params.get('oat'));
            }

            const curveKeys = [...params.keys()].filter(k => k.startsWith('curve')).map(k => parseInt(k.match(/curve(\d+)/)[1])).sort((a,b) => a-b);
            if (curveKeys.length === 0) { addCurve(); return; }
            const maxIndex = Math.max(...curveKeys);
            for (let i = 1; i <= maxIndex; i++) {
                const curveParam = params.get(`curve${i}`);
                const nameParam = params.get(`name${i}`);
                if (curveParam) {
                    const [x1, y1, x2, y2] = curveParam.split(SEPARATOR).map(parseFloat);
                    if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
                        addCurve({ x1, y1, x2, y2, name: nameParam ? decodeURIComponent(nameParam) : null });
                    }
                }
            }


            if (!isNaN(oat)) {
                document.getElementById('oat-input').value = oat;
                calculateLWT();
                displayDefaultCrosshair();
            }
        }

        function calculateLWT() {
            const results = document.getElementById('lwt-results');
            results.innerHTML = '';
            if (isNaN(oat)) return;
            curves.forEach(c => {
                const lwt = getLWTForCurve(c, oat);
                const p = document.createElement('p');
                p.textContent = `${c.name}: LWT = ${lwt.toFixed(1)} °C`;
                results.appendChild(p);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            renameModal = new bootstrap.Modal(document.getElementById('renameModal'));
            renameInput = document.getElementById('renameInput');
            renameSave = document.getElementById('renameSave');

            // Save on button click
            renameSave.addEventListener('click', saveRename);

            // Save on Enter key in input field
            renameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                }
            });

            loadFromURL();
            document.getElementById('copy-clipboard').addEventListener('click', copyToClipboard);
            document.getElementById('add-curve').addEventListener('click', () => {
                if (curves.length === 0) addCurve();
                else {
                    const last = curves[curves.length - 1];
                    addCurve({ x1: last.x1, y1: last.y1 - 5, x2: last.x2, y2: last.y2, name: null });
                }
            });
            document.getElementById('oat-input').addEventListener('input', e => {
                oat = parseFloat(e.target.value);
                calculateLWT();
                displayDefaultCrosshair();
                updateURL();
            });
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>