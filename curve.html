<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dependent Heating Curve Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        body { padding: 20px; }
        #chart { max-height: 600px; cursor: crosshair; }
        .header-container { position: relative; }
        .by-line {
            position: absolute;
            bottom: 0;
            right: 0;
            color: #6c757d;
        }
        @media (max-width: 576px) {
            .by-line { position: static; text-align: right; margin-top: 0.5rem; }
        }
        .narrow-input { max-width: 8ch; }
        .lwt-input-group { min-width: 320px; }
        #lwt-results p { margin-bottom: 0.5rem; font-weight: 500; }
        .lwt-row { align-items: flex-start; }
        footer { margin-top: 4rem; text-align: center; color: #6c757d; font-size: 0.85rem; }
        .inputs-column { max-width: 400px; }
        .nav-tabs .nav-link {
            border-bottom-color: transparent;
        }
        .tab-content {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 0.375rem 0.375rem;
            padding: 1.5rem;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container mb-4">
            <h1 class="d-inline-block">Weather Dependent Heating Curve Visualizer</h1>
            <div class="by-line">
                By <a href="https://github.com/luksa" target="_blank">Marko Lukša</a>
            </div>
        </div>
        <p class="mb-4">
            This tool helps you visualize and fine-tune weather-dependent heating curves for heat pumps.
            Define each curve by two points, add multiple curves for easy comparison, and instantly see the leaving water temperature (LWT)
            for all curves at any chosen outdoor temperature.
        </p>
     
        <div class="row">
            <div class="col-md-4 order-md-1 mb-4 mb-md-0 inputs-column">
                <ul class="nav nav-tabs mb-0" id="curveTabs" role="tablist"></ul>
                <div class="tab-content" id="curveTabContent"></div>
                <button id="add-curve" class="btn btn-primary mt-3">Add Another Curve</button>
            </div>
         
            <div class="col-md-8 order-md-2">
                <canvas id="chart" class="mb-4"></canvas>
             
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3">What's my LWT at a given outdoor temperature?</h5>
                        <div class="row lwt-row">
                            <div class="col">
                                <div class="input-group lwt-input-group">
                                    <span class="input-group-text">Outdoor Temp</span>
                                    <input id="oat-input" type="number" step="1" class="form-control narrow-input">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                            <div class="col" id="lwt-results"></div>
                        </div>
                    </div>
                </div>
             
                <div class="card">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                            <h5 class="card-title mb-0">Share this curve</h5>
                            <button id="copy-clipboard" class="btn btn-secondary">
                                <i class="fas fa-copy"></i> Copy Link
                            </button>
                        </div>
                        <small id="copy-feedback" class="text-success d-none mt-3 d-block">Link copied to clipboard!</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
        Vibe-coded by <a href="https://github.com/luksa" target="_blank">Marko Lukša</a> with
        <a href="https://grok.com" target="_blank">Grok</a>.
        Inspired by <a href="https://vscope.at/heizkurve" target="_blank">vscope.at/heizkurve</a>.
    </footer>

    <!-- Bootstrap Rename Modal -->
    <div class="modal fade" id="renameModal" tabindex="-1" aria-labelledby="renameModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="renameModalLabel">Rename Curve</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <label for="renameInput" class="form-label">Curve name</label>
                    <input type="text" class="form-control" id="renameInput">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="renameSave">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let curves = [];
        let chart;
        let oat;
        const DEFAULT_MIN_X = -10;
        const DEFAULT_MAX_X = 25;
        const DEFAULT_MIN_Y = 20;
        const DEFAULT_MAX_Y = 40;
        const TOP_PADDING    = 5;
        const BOTTOM_PADDING = 5;
        const LEFT_PADDING   = 5;
        const RIGHT_PADDING  = 5;
        const SEPARATOR = ',';

        function roundTo5(num) { return Math.round(num / 5) * 5; }
        function ceilTo5(num)  { return Math.ceil(num  / 5) * 5; }
        function floorTo5(num) { return Math.floor(num / 5) * 5; }

        let renameModal = null;
        let renameInput = null;
        let renameSave  = null;
        let currentRenameIndex = -1;

        function openRenameModal(index) {
            currentRenameIndex = index;
            renameInput.value = curves[index].name;
            renameModal.show();
            renameModal._element.addEventListener('shown.bs.modal', function handler() {
                renameInput.focus();
                renameInput.select();
                renameModal._element.removeEventListener('shown.bs.modal', handler);
            });
        }

        function saveRename() {
            if (currentRenameIndex === -1) return;
            const newName = renameInput.value.trim() || `Curve ${currentRenameIndex + 1}`;
            curves[currentRenameIndex].name = newName;

            const activeTabButton = document.querySelector('.nav-link.active');
            const activeTabId = activeTabButton?.id;

            updateTabsAndContent();
            updateChart();
            updateURL();
            calculateLWT();

            if (activeTabId) {
                const tabToActivate = document.getElementById(activeTabId);
                if (tabToActivate) new bootstrap.Tab(tabToActivate).show();
            }

            renameModal.hide();
        }

        function updateRemoveButtons() {
            document.querySelectorAll('.remove').forEach(btn => {
                btn.style.display = curves.length === 1 ? 'none' : 'block';
            });
        }

        function updateTabsAndContent() {
            const tabList = document.getElementById('curveTabs');
            const tabContent = document.getElementById('curveTabContent');
            tabList.innerHTML = '';
            tabContent.innerHTML = '';

            curves.forEach((curve, i) => {
                const tabId = `curve-tab-${i}`;
                const li = document.createElement('li');
                li.className = 'nav-item';
                li.innerHTML = `
                    <button class="nav-link ${i === 0 ? 'active' : ''}" 
                            id="${tabId}-tab" 
                            data-bs-toggle="tab" 
                            data-bs-target="#${tabId}" 
                            type="button" role="tab">
                        ${curve.name}
                    </button>`;
                tabList.appendChild(li);

                const pane = document.createElement('div');
                pane.className = `tab-pane fade ${i === 0 ? 'show active' : ''}`;
                pane.id = tabId;
                pane.role = 'tabpanel';
                pane.innerHTML = `
                    <div class="mb-4">
                        <h6 class="fw-bold">Low Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input y1" value="${curve.y1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x1" value="${curve.x1}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4">
                        <h6 class="fw-bold">High Outdoor Temperature Point</h6>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Leaving Water Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input y2" value="${curve.y2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center">
                            <label class="col-sm-7 col-form-label text-sm-end">Outdoor Temp</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input x2" value="${curve.x2}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4">
                        <h6 class="fw-bold">Adjustments</h6>
                        <div class="row align-items-center mb-2">
                            <label class="col-sm-7 col-form-label text-sm-end">Offset</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input offset" value="${curve.offset ?? 0}" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4">
                        <h6 class="fw-bold">Space heating settings</h6>
                        <div class="row align-items-center mb-2">
                            <label class="col-sm-7 col-form-label text-sm-end">Heating Minimum</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input hmin" value="${curve.hmin ?? ''}" placeholder="—" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                        <div class="row align-items-center mb-3">
                            <label class="col-sm-7 col-form-label text-sm-end">Heating Maximum</label>
                            <div class="col-sm-5">
                                <div class="input-group">
                                    <input type="number" class="form-control narrow-input hmax" value="${curve.hmax ?? ''}" placeholder="—" step="1">
                                    <span class="input-group-text">°C</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="d-flex gap-2">
                        <button class="btn btn-primary rename" data-index="${i}">Rename Curve</button>
                        <button class="btn btn-danger remove" data-index="${i}">Remove Curve</button>
                    </div>`;
                tabContent.appendChild(pane);
            });

            document.querySelectorAll('input[type="number"]').forEach(el => {
                el.removeEventListener('change', updateAll);
                el.removeEventListener('input', updateAll);
                el.addEventListener('change', updateAll);
                el.addEventListener('input', updateAll);
            });

            document.querySelectorAll('.rename').forEach(btn => {
                btn.addEventListener('click', () => openRenameModal(parseInt(btn.dataset.index)));
            });
            document.querySelectorAll('.remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    curves.splice(parseInt(btn.dataset.index), 1);
                    updateTabsAndContent();
                    updateAll();
                });
            });

            updateRemoveButtons();
        }

        function addCurve(data = {x1: -5, y1: 45, x2: 20, y2: 25, name: null, offset: 0, hmin: null, hmax: null}) {
            const defaultName = `Curve ${curves.length + 1}`;
            curves.push({
                x1: data.x1,
                y1: data.y1,
                x2: data.x2,
                y2: data.y2,
                name: data.name || defaultName,
                offset: data.offset ?? 0,
                hmin: data.hmin ?? null,
                hmax: data.hmax ?? null
            });
            updateTabsAndContent();
            updateAll();

            const newTabBtn = document.querySelector(`#curve-tab-${curves.length - 1}-tab`);
            if (newTabBtn) new bootstrap.Tab(newTabBtn).show();
        }

        function getNumber(val, def = null) {
            if (val === "" || val == null) return def;
            const n = parseFloat(val);
            return isNaN(n) ? def : n;
        }

        function updateAll() {
            const activePane = document.querySelector('.tab-pane.active');
            if (!activePane) return;

            const index = Array.from(document.querySelectorAll('.tab-pane')).indexOf(activePane);
            if (index < 0 || index >= curves.length) return;

            const curve = curves[index];

            curve.y1 = getNumber(activePane.querySelector('.y1')?.value, curve.y1);
            curve.x1 = getNumber(activePane.querySelector('.x1')?.value, curve.x1);
            curve.y2 = getNumber(activePane.querySelector('.y2')?.value, curve.y2);
            curve.x2 = getNumber(activePane.querySelector('.x2')?.value, curve.x2);

            curve.offset = getNumber(activePane.querySelector('.offset')?.value, 0);
            curve.hmin   = getNumber(activePane.querySelector('.hmin')?.value, null);
            curve.hmax   = getNumber(activePane.querySelector('.hmax')?.value, null);

            updateChart();
            updateURL();
            calculateLWT();
            displayDefaultCrosshair();
        }

        function applyOffsetAndClamp(baseLWT, offset, hmin, hmax) {
            let lwt = baseLWT + (offset || 0);
            if (hmin != null) lwt = Math.max(lwt, hmin);
            if (hmax != null) lwt = Math.min(lwt, hmax);
            return lwt;
        }

        function getLWTForCurve(curve, oat, useOffset = true) {
            let points = [{x: curve.x1, y: curve.y1}, {x: curve.x2, y: curve.y2}].sort((a, b) => a.x - b.x);
            const left = points[0];
            const right = points[1];

            let baseLWT;
            if (oat <= left.x) baseLWT = left.y;
            else if (oat >= right.x) baseLWT = right.y;
            else {
                const slope = (right.y - left.y) / (right.x - left.x);
                baseLWT = left.y + slope * (oat - left.x);
            }

            return useOffset 
                ? applyOffsetAndClamp(baseLWT, curve.offset, curve.hmin, curve.hmax)
                : applyOffsetAndClamp(baseLWT, 0,           curve.hmin, curve.hmax);
        }

        function updateChart() {
            if (chart) chart.destroy();
            const ctx = document.getElementById('chart').getContext('2d');

            let allX = [], allBaseY = [], allOffsetY = [];
            curves.forEach(c => {
                allX.push(c.x1, c.x2);
                const baseMin = Math.min(c.y1, c.y2);
                const baseMax = Math.max(c.y1, c.y2);
                allBaseY.push(baseMin, baseMax);

                const offMin = applyOffsetAndClamp(baseMin, c.offset, c.hmin, c.hmax);
                const offMax = applyOffsetAndClamp(baseMax, c.offset, c.hmin, c.hmax);
                allOffsetY.push(offMin, offMax);
            });

            const minX = allX.length ? Math.min(...allX) : DEFAULT_MIN_X;
            const maxX = allX.length ? Math.max(...allX) : DEFAULT_MAX_X;
            const displayMinX = floorTo5(minX - LEFT_PADDING);
            const displayMaxX = ceilTo5 (maxX + RIGHT_PADDING);

            const rawMinY = Math.min(...allBaseY, ...allOffsetY);
            const rawMaxY = Math.max(...allBaseY, ...allOffsetY);
            const displayMinY = floorTo5(rawMinY - BOTTOM_PADDING);
            const displayMaxY = ceilTo5 (rawMaxY + TOP_PADDING);

            const datasets = [];

            curves.forEach((c, i) => {
                const hue = i * 137 % 360;
                const baseColor = `hsl(${hue}, 70%, 50%)`;
                const dimColor  = `hsl(${hue}, 50%, 65%)`;

                let points = [{x: c.x1, y: c.y1}, {x: c.x2, y: c.y2}].sort((a,b)=>a.x-b.x);
                const left  = points[0];
                const right = points[1];

                // ───────────────────────────────────────────────
                //  Offset curve — always shown
                // ───────────────────────────────────────────────
                const dataOffset = [];
                for (let t = displayMinX; t <= Math.floor(left.x); t++) {
                    dataOffset.push({x: t, y: getLWTForCurve(c, t, true)});
                }
                dataOffset.push({x: left.x, y: getLWTForCurve(c, left.x, true)});
                for (let t = Math.ceil(left.x); t < Math.floor(right.x); t++) {
                    dataOffset.push({x: t, y: getLWTForCurve(c, t, true)});
                }
                dataOffset.push({x: right.x, y: getLWTForCurve(c, right.x, true)});
                for (let t = Math.ceil(right.x); t <= displayMaxX; t++) {
                    dataOffset.push({x: t, y: getLWTForCurve(c, t, true)});
                }

                datasets.push({
                    label: c.offset !== 0 ? `${c.name} (with offset)` : `${c.name}`,
                    data: dataOffset,
                    borderColor: baseColor,
                    backgroundColor: baseColor,
                    borderWidth: 3,
                    pointRadius: c.offset !== 0 ? 0 : ctx => {
                        const x = ctx.parsed.x;
                        return (Math.abs(x - Math.round(left.x)) < 0.1 || Math.abs(x - Math.round(right.x)) < 0.1) ? 6 : 0;
                    },
                    tension: 0
                });

                // ───────────────────────────────────────────────
                //  Unoffset curve — shown only when offset is non-zero
                // ───────────────────────────────────────────────
                if (c.offset !== 0) {
                    const dataBase = [];
                    for (let t = displayMinX; t <= Math.floor(left.x); t++) {
                        dataBase.push({x: t, y: getLWTForCurve(c, t, false)});
                    }
                    dataBase.push({x: left.x, y: getLWTForCurve(c, left.x, false)});
                    for (let t = Math.ceil(left.x); t < Math.floor(right.x); t++) {
                        dataBase.push({x: t, y: getLWTForCurve(c, t, false)});
                    }
                    dataBase.push({x: right.x, y: getLWTForCurve(c, right.x, false)});
                    for (let t = Math.ceil(right.x); t <= displayMaxX; t++) {
                        dataBase.push({x: t, y: getLWTForCurve(c, t, false)});
                    }

                    datasets.push({
                        label: `${c.name} (w/o offset)`,
                        data: dataBase,
                        borderColor: dimColor,
                        backgroundColor: dimColor,
                        borderWidth: 2,
                        borderDash: [4, 3],
                        pointRadius: ctx => {
                            const x = ctx.parsed.x;
                            return (Math.abs(x - Math.round(left.x)) < 0.1 || Math.abs(x - Math.round(right.x)) < 0.1) ? 6 : 0;
                        },
                        tension: 0
                    });
                }
            });

            const baseAnnotations = {
                vLine: {
                    type: 'line',
                    scaleID: 'x',
                    value: null,
                    borderColor: 'rgba(80,80,80,0.9)',
                    borderWidth: 1.5,
                    borderDash: [6,4],
                    label: { display: false, content: '', position: 'end', backgroundColor: 'rgba(0,0,0,0.8)', color: '#fff', font: {size:12, weight:'bold'}, padding:6, borderRadius:4 }
                }
            };

            curves.forEach((c, i) => {
                const hue = i * 137 % 360;
                baseAnnotations[`hLine${i}`] = {
                    type: 'line',
                    scaleID: 'y',
                    value: null,
                    borderColor: `hsl(${hue}, 70%, 50%)`,
                    borderWidth: 1.5,
                    borderDash: [6,4],
                    label: { display: false, content: '', position: 'start', backgroundColor: `hsl(${hue}, 70%, 50%)`, color: '#fff', font: {size:11, weight:'bold'}, padding:5, borderRadius:4 }
                };
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        tooltip: { enabled: false },
                        legend: { position: 'top' },
                        annotation: { annotations: baseAnnotations }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: 'Outdoor Temperature (°C)' },
                            min: displayMinX,
                            max: displayMaxX,
                            ticks: { stepSize: 5 }
                        },
                        y: {
                            title: { display: true, text: 'Leaving Water Temperature (°C)' },
                            min: displayMinY,
                            max: displayMaxY,
                            ticks: { stepSize: 5 }
                        }
                    },
                    onHover: (event, activeElements) => {
                        const area = chart.chartArea;
                        if (!event.native || !area) return;
                        const x = event.x, y = event.y;
                        if (x < area.left || x > area.right || y < area.top || y > area.bottom) {
                            displayDefaultCrosshair();
                            return;
                        }
                        const xVal = chart.scales.x.getValueForPixel(x);
                        const snapped = Math.round(xVal);
                        displayCrosshair(snapped);
                    }
                },
                plugins: [{
                    id: 'hideCrosshairOnLeave',
                    afterEvent: (ch, args) => {
                        if (args.event.type === 'mouseout') displayDefaultCrosshair();
                    }
                }]
            });
        }

        function displayDefaultCrosshair() {
            displayCrosshair(oat);
        }

        function displayCrosshair(oatVal) {
            if (isNaN(oatVal)) {
                chart.options.plugins.annotation.annotations.vLine.value = null;
                chart.options.plugins.annotation.annotations.vLine.label.display = false;
                curves.forEach((_, i) => {
                    const h = chart.options.plugins.annotation.annotations[`hLine${i}`];
                    h.value = null;
                    h.label.display = false;
                });
                chart.update('none');
                return;
            }

            chart.options.plugins.annotation.annotations.vLine.value = oatVal;
            chart.options.plugins.annotation.annotations.vLine.label.content = `Outdoor: ${oatVal} °C`;
            chart.options.plugins.annotation.annotations.vLine.label.display = true;

            curves.forEach((c, i) => {
                const lwt = getLWTForCurve(c, oatVal, true);
                const rounded = Math.round(lwt * 10) / 10;
                const h = chart.options.plugins.annotation.annotations[`hLine${i}`];
                h.value = rounded;
                h.label.content = `LWT: ${rounded} °C`;
                h.label.display = true;
            });

            chart.update('none');
        }

        function updateURL() {
            const parts = [];
            curves.forEach((c, i) => {
                let curveStr = `${c.x1}${SEPARATOR}${c.y1}${SEPARATOR}${c.x2}${SEPARATOR}${c.y2}`;
                if (c.offset !== 0 || c.hmin != null || c.hmax != null) {
                    curveStr += `${SEPARATOR}${c.offset}`;
                    if (c.hmin != null || c.hmax != null) {
                        curveStr += `${SEPARATOR}${c.hmin ?? ''}${SEPARATOR}${c.hmax ?? ''}`;
                    }
                }
                parts.push(`curve${i+1}=${curveStr}`);
                parts.push(`name${i+1}=${encodeURIComponent(c.name)}`);
            });
            if (!isNaN(oat)) parts.push(`oat=${oat}`);

            parts.sort();
            const query = parts.join('&');
            const newUrl = query ? `?${query}` : '';
            history.replaceState(null, '', window.location.pathname + newUrl);
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(window.location.href);
                const fb = document.getElementById('copy-feedback');
                fb.classList.remove('d-none');
                setTimeout(() => fb.classList.add('d-none'), 3000);
            } catch {
                alert('Failed to copy. Please copy URL manually.');
            }
        }

        function loadFromURL() {
            const params = new URLSearchParams(window.location.search.substring(1));
            if (params.has('oat')) {
                oat = parseFloat(params.get('oat'));
            }

            const curveKeys = [...params.keys()]
                .filter(k => k.startsWith('curve'))
                .map(k => parseInt(k.match(/curve(\d+)/)?.[1] ?? -1))
                .filter(n => n >= 1)
                .sort((a,b)=>a-b);

            if (curveKeys.length === 0) {
                addCurve();
                return;
            }

            const maxIdx = Math.max(...curveKeys);
            for (let i = 1; i <= maxIdx; i++) {
                const curveParam = params.get(`curve${i}`);
                if (!curveParam) continue;

                const parts = curveParam.split(SEPARATOR).map(s => s.trim());
                if (parts.length < 4) continue;

                const [x1s, y1s, x2s, y2s, ...rest] = parts;
                const x1 = parseFloat(x1s);
                const y1 = parseFloat(y1s);
                const x2 = parseFloat(x2s);
                const y2 = parseFloat(y2s);

                if ([x1,y1,x2,y2].some(isNaN)) continue;

                let offset = 0, hmin = null, hmax = null;
                if (rest.length >= 1) offset = parseFloat(rest[0]) || 0;
                if (rest.length >= 3) {
                    hmin = rest[1] ? parseFloat(rest[1]) : null;
                    hmax = rest[2] ? parseFloat(rest[2]) : null;
                }

                const name = params.has(`name${i}`) ? decodeURIComponent(params.get(`name${i}`)) : null;

                addCurve({x1, y1, x2, y2, name, offset, hmin, hmax});
            }

            if (!isNaN(oat)) {
                document.getElementById('oat-input').value = oat;
                calculateLWT();
                displayDefaultCrosshair();
            }
        }

        function calculateLWT() {
            const container = document.getElementById('lwt-results');
            container.innerHTML = '';
            if (isNaN(oat)) return;

            curves.forEach(c => {
                const lwt = getLWTForCurve(c, oat, true);
                const p = document.createElement('p');
                p.textContent = `${c.name}: LWT = ${lwt.toFixed(1)} °C`;
                container.appendChild(p);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            renameModal = new bootstrap.Modal(document.getElementById('renameModal'));
            renameInput = document.getElementById('renameInput');
            renameSave  = document.getElementById('renameSave');

            renameSave.addEventListener('click', saveRename);
            renameInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                }
            });

            loadFromURL();

            document.getElementById('copy-clipboard').addEventListener('click', copyToClipboard);
            document.getElementById('add-curve').addEventListener('click', () => {
                if (curves.length === 0) {
                    addCurve();
                } else {
                    const last = curves[curves.length - 1];
                    addCurve({
                        x1: last.x1, y1: last.y1,
                        x2: last.x2, y2: last.y2 - 5,
                        offset: 0,
                        hmin: last.hmin,
                        hmax: last.hmax
                    });
                }
            });

            document.getElementById('oat-input').addEventListener('input', e => {
                oat = parseFloat(e.target.value);
                calculateLWT();
                displayDefaultCrosshair();
                updateURL();
            });
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>